/**
 * Created by vishnu on 21/03/2018.
 */
var path = require('path'),
    logger = require(path.resolve('./logger')),
    Config = mongoose.model('PsCoreConfig'),
    errorHandler = require('../../../core/server/controllers/errors.server.controller');
var fs = require('fs');
var date = Date(Date.now());
date = date.toString();

function exportLogs(exportOptions, callback) {
    logger.query(exportOptions, function (err, results) {
        if (err) {
            logger.error('Unable to export logs' + 'error: ' + err, { Date: date });
            callback(null);
            return;
        }
        callback(results.file);
    });
}

/**
 * Exports logs generated by winston logger
 * @param req
 * @param res
 */
exports.exportLogs = function (req, res) {
    logger.info('Received export log request from User ' + req.user.username, { Date: date });

    if (!req.body.exportOptions) {
        logger.error('Could not Export logs. No exportOptions parameter found in request body', { Date: date });
        res.sendStatus(400);
        return;
    }
    exportLogs(req.body.exportOptions, function (logs) {
        if (!logs)
            res.send(500);
        else
            res.send({ data: logs });
    });

};

/**
 * Exports logs generated by Morgan logger.
 * Contains routes accessed by IPs
 * @param req
 * @param res
 */
exports.exportRouteAccessLogs = function (req, res) {

    fs.readFile(path.resolve('./access.log'), function (err, data) {
        if (err) {
            logger.error('Unable to export Route Access logs' + ' error: ' + err, { Date: date });
            res.sendStatus(500);
            return;
        }
        res.send({ logs: data.toString() });
    });
};

/**
 * Queries OS for its logs and exports it.
 * For linux, journalctl logs are used
 * @param req
 * @param res
 */
exports.exportOSLogs = function (req, res) {
    logger.info('Received export OS log request from User ' + req.user.username, { Date: date });

    if (!req.body.exportOptions) {
        logger.error('Could not Export OS logs. No exportOptions parameter found in request body', { Date: date });
        res.sendStatus(400);
        return;
    }
    var sDate = '';
    var uDate = '';
    if (req.body.exportOptions.startDate) {
        sDate = new Date(req.body.exportOptions.startDate).toISOString();
        sDate = sDate.replace(/T/, ' ').replace(/\..+/, '');
    }
    if (req.body.exportOptions.endDate) {
        uDate = new Date(req.body.exportOptions.endDate).toISOString();
        uDate = uDate.replace(/T/, ' ').replace(/\..+/, '');
    }

    // Create command string
    var command = 'journalctl --since "' + sDate + '" --until "' + uDate + '"';
    command += req.body.exportOptions.order == 'desc' ? " --reverse" : '';
    command += "> /tmp/OSLogs.log";

    // Execute command
    var exec = require('child_process').exec;
    exec(command, function (error) {
        if (error !== null) {
            logger.error('Unable to execute OS Log command. exec error: ' + { error: error }, { Date: date });
            res.sendStatus(500);

        }
        else {
            // Read file
            fs.readFile('/tmp/OSLogs.log', function (err, data) {
                if (err) {
                    logger.error('Unable to export OS logs' + 'error: ' + err, { Date: date });
                    res.sendStatus(500);
                    return;
                }
                res.send({ logs: data.toString() });
            });
        }
    });


};

exports.repairLogs = function (req, res) {
    repairLogs();
    res.status(200).send({ message: "Repairing logs" });
};

/**
 * Scans for all .log files in the project's root directory
 * Each file is opened and scanned for \00 character.
 * If the character is found, it is removed and file is written back to disk
 *
 * Need: Sometimes when logger is in use and power is cut off,
 * invalid characters are getting inserted in the log file.
 * This crashes the logger query that is used for export log
 * and notifications.
 */
function repairLogs() {
    fs.readdir('./', function (err, files) {
        if (err) {
            console.error(err);
            return;
        }
        files.forEach(function (file) {
            if (file.indexOf('.log') != -1) {
                readRepairWrite(file);
            }
        });
    });
    function readRepairWrite(file) {
        if (file == 'npm-debug.log')
            return;
        fs.readFile('./' + file, function (err, data) {
            if (err) {
                console.error(err);
                return;
            }
            var str = data.toString();
            var repaired = str.replace(/\00/g, '');

            if (str.length != repaired.length) {
                fs.writeFile('./' + file, repaired, function (err) {
                    if (err)
                        console.error(err);
                });
            }
        });
    }
}
/**
 * Exports logs generated by ps core.
 * @param req
 * @param res
 */
exports.exportPsCoreAppLogs = function (req, res) {
    var logFilePath = req.psScoreConfig.logFilePath;
    if (!logFilePath) {
        logger.error('Unable to export logs', { Date: date });
        res.status(500).send({ statusText: "No logs found for this machine!" });
        return;
    }
    fs.readFile(path.resolve(logFilePath), function (err, data) {
        if (err) {
            logger.error('Unable to export logs' + ' error: ' + err, { Date: date });
            res.sendStatus(500);
            return;
        }
        res.send({ logs: data.toString() });
    });
};
/**
 * Middleware for finding ps core Configuration by id and attaching it to req
 * @param req
 * @param res
 * @param next
 * @param id
 */
exports.psCoreConfigById = function (req, res, next, id) {
    Config.findById(id).exec(function (err, config) {
        if (err) {
            logger.error("Error while finding psconfig data" + ' error: ' + err, { Date: date });
            return next(err);
        } else if (!config) {
            return res.status(404).send({ message: "No psconfig with that identifier has been found" });
        }
        req.psScoreConfig = config;
        next();
    })
};

exports.internalFunctions = {
    exportLogs: exportLogs
    //exportRouteAccessLogs:exportRouteAccessLogs,
    //exportOSLogs:exportOSLogs
};
